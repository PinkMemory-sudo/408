# Linux



## 基本概念



**挂载**



在linux操作系统中， 挂载是指将一个设备（通常是存储设备）挂接到一个已存在的目录上。 我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上， 然后通过访问这个目录来访问存储设备。



用户地址空间与内核地址空间

Linux 操作系统和驱动程序运行在内核空间，应用程序运行在用户空间，两者不能简单地使用指针传递数据，因为Linux使用的虚拟内存机制，用户空间的数据可能被换出，当内核空间使用用户空间指针时，对应的数据可能不在内存中。



**内核地址映射模型**

**进程代码**中的地址为逻辑地址，经过段页式地址映射后，才真正访问物理内存。





## 常用命令



**打包压缩**



**压缩命令**

 ""

**Md5sum** 

查看文件的MD5



**awk**

​	强大的文本分析工具，比cut更好用**对数据进行分析获取**。

一次读一行，即读到\n，然后按默认分隔符(空格)切割，与cut相比，多个空格或单个空格都是分隔符，而cut只能是指定的分隔符

命令格式：``

awk来获得第几列，$0表示所有列

```
awk -F ',' '{print $3,$4}' 358a8b01d8fe44adb6da0bbc88822646.csv 
```

**后面接的是文件**，如果想处理字符串，可以通过`echo `

列之间可以加字符串来连接

```shell
awk -F ',' '{print $3"-"$4}' 358a8b01d8fe44adb6da0bbc88822646.csv 
```

两列之间会多个-来连接

awk获得某行

```
awk '\root\' 文件
```

查找以root开头的行

```
awk '\^root\' 文件
```

**可以有多个action**

action需要用引号包括

\内容\表示查找

{print }表示打印

awk获得某(多)行某(多)列

```
awk '\^root\{print $n}' 文件
```

*内置变量*

```
NF 浏览记录的字段个数
NR 已读的记录数
```

*内置函数*

获得字符串长度

```shell
awk 'BEGIN { print length("this is a text") }'
```

字符串转大写

```shell
awk -F ':' '{ print toupper($1) }' /etc/passwd
```

*条件操作，正则表达式*



**Date**

用来显示和设置系统时间

*格式化*

date +"格式化字符串"

```shell
date +"%Y-%m-%d" 
```

%y与%Y，y取年的后两位，Y取四位

UTC：世界协调时间

CST：中央标准时间

| 参数 | 描述                           |
| ---- | ------------------------------ |
| -u   | 显示utc时间(不加-u表示使用CST) |



**wget**



**cp**

| 参数 | 说明                           |
| ---- | ------------------------------ |
| -r   | 拷贝所有(包括文件夹和子文件夹) |
|      |                                |
|      |                                |



**mv**

移动或重命名文件(夹)

| 参数 | 说明 |
| ---- | ---- |
|      |      |
|      |      |
|      |      |



**mkdir** 

| 命令 | 参数                                         |
| ---- | -------------------------------------------- |
| -p   | 创建文件夹时可能父目录不存在，不存在时会创建 |



**split**

split 要切割的文件 切割后文件的前缀 [选项列表]

切割文件

| 参数    | 说明                           |
| ------- | ------------------------------ |
| - 数字  | 按多少行拆分，可以简写位-数字  |
| -a 数字 | 后缀的位数，默认是2            |
| -d      | 后缀默认是字母，-d表示使用数字 |
| -b 字节 | 按大小分隔                     |



**大括号扩展**

{}可以和字符串拼接，生成多个字符串

```bash
echo foo{1,2,3}.txt
```

```bash
foo1.txt foo2.txt foo3.txt
```



{}中有n个，就会拼成n+一个字符串，相当于用,进行分隔，每个字符串与当前字符串进行拼接



## 常用工具



**curl**

用来请求web的命令行工具，curl就是client的url工具



| 参数             | 描述                                     |
| ---------------- | ---------------------------------------- |
| -X               | 指定请求方式                             |
| -o/--output      | 把输出写到该文件中                       |
| -O/--remote-name | 把输出写到该文件中，保留远程文件的文件名 |
| -d               |                                          |
| --data-binary    |                                          |
| -s/--silent      | 静音模式。不输出任何东西                 |
|                  |                                          |



-H 头信息

-A 指定User-Agent(也可以通过-H指定)

-b 发送cookie

-s 静默模式，不输出任何东西

-o 将响应保存为文件





## VIM

常用命令

| 命令                    | 描述             |
| ----------------------- | ---------------- |
| G                       | 到最后一行       |
| o                       | 在光标下一行插入 |
| u                       | 撤销             |
| /字符串                 | 查询             |
| /%s/目标/替换的字符串/g | 全局替换         |
| yy                      | 复制             |
| p                       | 粘贴             |
| dd                      | 剪切             |

插入

| 命令 | 描述             |
| ---- | ---------------- |
| a    | 光标后插入       |
| A    | 行位插入         |
| i    | 光标前插入       |
| I    | 行首插入         |
| o    | 光标的下一行插入 |
| O    | 光标上一行插入   |

命令

|          |            |
| -------- | ---------- |
| set nu   | 显式行     |
| set nonu | 取消显示行 |
| gg       | 到第一行   |
| G        | 到最后一行 |
| nG       | 到第n行    |
| $        | 到行尾     |
| 0        | 到行首     |
| u        | 撤销       |
| /字符串  | 搜索       |

复制剪切

| 命令       | 说明                    |
| ---------- | ----------------------- |
| yy         | 复制当前行              |
| nyy        | 复制当前行和以下的n-1行 |
| dd         | 剪切                    |
| ndd        | 剪切n行                 |
| p/P        | 粘贴                    |
| nohlsearch | 去掉黄色高亮 或者nohl   |



**打包压缩**

tar

gzip





## 重定向



标准输入输出：标准输入就是键盘，标准输出就是屏幕

重定向就是改变输入输出的方向，通常将输入重定向为命令的执行结果或文件，输出重定向为文件。



*输入重定向*

| 命令           | 描述                                       |
| -------------- | ------------------------------------------ |
| 命令 < 文件    | 将文件作为命令的输入                       |
| 命令 << 分界符 | 从标准输入设备中输入，到自定义的分界符截止 |
| 文件1<文件2    | 将文件2输入到文件1                         |



*输出重定向*

分为标准输出重定向和错误输出重定向。输出重定向又分为追加和重写

即：**想要把原来显示到屏幕上的信息重定向到文件，注意要区别对待两种信息**

| 命令            | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| 命令>文件       | 将命令结果重定向到文件，出错时不会重定向而是标准输出(**默认为命令1>文件**) |
| 命令2>文件      | 将错误信息重定向到文件中                                     |
| 命令>>文件      | 追加的形式重定向                                             |
| 命令2>>文件     | 追加的形式重定向                                             |
| 命令>> 文件2>&1 | 将两种信息都输出到文件中，等效与 命令 &>>文件                |

输入输出一共有三种：

* 0表述标准输入
* 1表示标准输出
* 2表述错误的标准输出



使用场景：

/dev/null可以理解成是一个黑洞，把不要的信息塞进去

```shell
2>/dev/null # 将错误信息输出到黑洞
```



黑洞在前，就都不要了

```shell
>/dev/null 2>&1 # 默认就是标准，等效与1>/dev/null 2>&1
```



```shell
2>&1 >/dev/null
```



```shell
2>&1 #将错误信息重定向到标准输出，也就是屏幕显式所有信息
```



**ulimit**



**which**

which  在PATH变量查找可执行文件(命令)

也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。



**whereis**

用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）

linux系统会将 系统内的所有文件都记录在一个数据库文件中。

当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。



**head**

查看文件开头部分

```shell
head [参数] [文件]
```

| 参数          | 描述                   |
| ------------- | ---------------------- |
| -n 显示的行数 | 查看前几行，默认是10行 |



**env** 

获得环境变量



**wc**

用于计算字数

```
wc [-clw][文件...]
```

| 参数 | 描述       |
| ---- | ---------- |
| -c   | 显示字节数 |
| -l   | 显示行数   |
| -w   | 显示字数   |



# Shell



适合用来做自动化，将需要的命令写成一个文件运行，复杂的功能可以有python实现，shell去运行python脚本

包括了两种概念：

* 用来操作Linux内核的一条条命令
* 一条条命令组成的脚本

脚本就是解释性语言编写的程序，写完程序时，解释器一行行去读取我们得代码去编译执行，效率低，但是他们可移植性好，对文件等操作便利。

我们常说有多少种Shell，其实说的是Shell脚本解释器：sh，bash等。bash是Linux标准默认的shell。



**什么时候不用shell**

* 资源密集的操作，尤其进行排序，hash等等
* 需要处理大任务的数学操作，尤其是浮点运算，精确运算，或者复杂的算术运算
* 需要大规模的文件操作
* 需要多维数组的支持



查看系统中有哪些shell

```sh
cat /etc/shells
```

查看系统的SHELL

```sh
cat $SHELL
```

mac默认的是zsh



**运行shell**

* 通过./xxx.sh运行(要保证xxx.sh是可执行的)
* 通过将脚本文件作为解释器的参数运行

运行shell时要指定路径，直接写xxx.sh会去linux 系统会去 PATH 里寻找有没有叫 xxx.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里。

```shell
#!/bin/bash
echo "Hello World !"
```

**#!** 表示指定解释器，然后可以添加可执行权限通过./执行

```shell
sh test.sh
```

这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。



多行注释

```shell
:<<EOF
注释内容...
注释内容...
注释内容...
EOF
```

EOF可以换成其他字符，保证前后一致



## 变量



### 变量类型



**局部变量**

局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。



**环境变量**

所有的程序，包括shell启动的程序，都能访问环境变量，shell脚本也可以定义环境变量。



**shell变量**

shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行。



**特殊变量**

除了字母数字下划线，包含了其他特殊字符，比如$0

| 选项 | 描述                                                    |
| ---- | ------------------------------------------------------- |
| $0   | 该脚本的文件名                                          |
| $n   | 第n个参数                                               |
| $#   | 参数的个数                                              |
| $*   | 取所有参数,加双引号时"$*"会将所有参数作为一个字符串整体 |
| $@   | 取所有参数，加双引号"$@"，会分成多个                    |
| $?   | 最后运行的命令的状态                                    |
| $$   | 当前脚本运行的PID                                       |



**$*与$@的区别**

* ∗和@和@ 都表示传递给函数或脚本的所有参数，不被双引号(" ")包含时，都以"1""1""2" … "$n" 的形式输出所有参数。

* 被双引号(" ")包含时，"∗"会将所有的参数作为一个整体，以"∗"会将所有的参数作为一个整体，以"1 2…2…n"的形式输出所有参数；"@"会将各个参数分开，以"@"会将各个参数分开，以"1" "2"…"2"…"n" 的形式输出所有参数。
* 即$@加不加引号都是一个个，$*加引号时会变成一个字符串



**只读变量**

只读变量的值不能被修改

定义制毒变量：

```shell
myUrl="http://see.xidian.edu.cn/cpp/shell/"
readonly myUrl
```



**删除变量**

```shell
unset 变量名
```

删除后的变量不会再使用，只读变量不能被删除

*变量的定义与使用*

定义：变量名=变量值  **等号左右不能有空格**

调用：$变量名，为了分隔，可以使用${变量名}



**字符串**

* 字符串可以用单引号双引号或者不加引号

* 单引号里的任何字符都会原样输出，不能引用变量

* 双引号里可以有变量，双引号里可以出现转义字符

| 功能           | 实现                                    |
| -------------- | --------------------------------------- |
| 拼接字符串     | 直接将字符串写在一起就行，不用加号      |
| 获得字符串长度 | ${#字符串变量}                          |
| 截取字符串     | ${字符串:1:4}，从第二位开始截取，截四位 |
| 查找           |                                         |



**数组**

shell只支持一维数组，并且不用限制大小，用()来表示数组，空格来分隔元素

| 功能               | 实现                     |
| ------------------ | ------------------------ |
| 定义数组           | 数组名=(值1 值2 ... 值n) |
| 数组最后添加元素   |                          |
| 读取数组           | ${数组名[下标]}          |
| 获得数组的所有元素 | ${数组名[@]}             |
| 获得数组长度       | ${#数组名[@]}            |

```
# 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
# 取得数组单个元素的长度
lengthn=${#array_name[n]}
```

数组的遍历

数组相关的

```shell
A=(a b c def)   
```

| 命令     | 解释                              | 结果      |
| -------- | --------------------------------- | --------- |
| ${A[@]}  | 返回数组全部元素                  | a b c def |
| ${A[*]}  | 同上                              | a b c def |
| ${A[0]}  | 返回数组第一个元素                | a         |
| ${#A[@]} | 返回数组元素总个数                | 4         |
| ${#A[*]} | 同上                              | 4         |
| ${#A[3]} | 返回第四个元素的长度，即def的长度 | 3         |
| A[3]=xzy | 则是将第四个组数重新定义为 xyz    |           |



## 函数

**函数或者脚本，可以理解成成一个自定义的命令**，这句话的含义是可以像使用命令一样调用方法和脚本，不用加括号



***函数的定义***

```shell
function 函数名(){

	return 返回值
}
```

函数中一般不写return，return的返回值只能是0-255,如果不见return，则最后一条命令的执行结果就是返回值



***函数的调用***

直接想命令一样进行调用

函数名 参数...



函数的参数和返回值

| 参数 | 描述                   |
| ---- | ---------------------- |
| $0   |                        |
| $n   |                        |
| $$   |                        |
| $?   | 获得上个函数执行的结果 |



\# !来指定下面代码的解析器( interpreter)



**export**

在shell中执行程序时，shell会提供一组环境变量。export可新增，修改或删除环境变量，供后续执行的程序使用

新增修改删除环境变量

export [参数] [变量名]=[变量值]

- -f 　代表[变量名称]中为函数名称，将函数暴露出去
- -n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。
- -p 　列出所有的shell赋予程序的环境变量。



| 用法             | 描述                            |
| ---------------- | ------------------------------- |
| export -p        | 列出当前的环境变量值，等效于env |
| export 变量名    | 定义环境变量                    |
| export 变量名=值 | 定义环境变量并赋值              |

生命周期：只在本次运行中有效



**source**

用来执行其他脚本，等同于.

任务很多时，写到一个函数或脚本不容易管理，可以分成多个函数，多个脚本，通过source和export互相调用。



**$的用法**

1. 获得脚本的参数
2. 引用变量(或环境变量)值
3. 命令替换 $()或``
4. 变量替换 ${}
5. 数值运算 $[]或$(())



### 内置函数



**echo**

* echo 后的内容默认是字符串
* 将内容重定向到一个文件中
* 需要输出多行时可以通过cat与EOF
* 用来写文件



**cat << EOF**

EOF是END Of File的缩写	

```shell
# 其用法如下:
<<EOF        //开始
....
EOF            //结束
```





**read**

read 变量名

从shell输入，赋值内变量



## 流程控制



### if

**字符串判断**

| 运算符 | 说明                                         | 举例                     |
| :----- | :------------------------------------------- | :----------------------- |
| =      | 检测两个字符串是否相等，相等返回 true。      | [ $a = $b ] 返回 false。 |
| !=     | 检测两个字符串是否相等，不相等返回 true。    | [ $a != $b ] 返回 true。 |
| -z     | 检测字符串长度是否为0，为0返回 true。        | [ -z $a ] 返回 false。   |
| -n     | 检测字符串长度是否不为 0，不为 0 返回 true。 | [ -n "$a" ] 返回 true。  |
| $      | 检测字符串是否为空，不为空返回 true。        | [ $a ] 返回 true。       |

数学判断

文件判断



### 循环



**for**

```shell
for loop in 1 2 3 4 5
do
    echo "The value is: $loop"
done
```

do表示循环的开始，done表示循环的结束



**while**

```shell
while condition
do
    command
done
```

条件写成 : 无限循环



**until** 

与while循环相反，不满足条件时执行循环



**case**

```shell
case 值 in
模式1)
    command1
    command2
    ...
    commandN
    ;;
模式2）
    command1
    command2
    ...
    commandN
    ;;
esac
```



`dirname "$0"`





## IO

遍历文件夹

```shell
for dataPath in /Users/chenguanlin/Documents/workspace/*; do
		echo $in
        dataName=$(basename "${dataPath}")
        echo $dataName
    done
```



读取文件



## ()的作用

1. 命令组，括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。多个命令之间用分好隔开



exit   退出当前进程并返回一个状态



**dirname与basename**







在双引号中使用变量或者转义字符，会替换成变量值

```shell
a=10
echo -e "Value of a is $a \n"
```

-e表示进行转义，没有-e回原样输出\n

可以使用 echo 命令的 -E 选项禁止转义，默认也是不转义的；使用 -n 选项可以禁止插入换行符。

| 转义字符 | 含义                             |
| -------- | -------------------------------- |
| \\       | 反斜杠                           |
| \a       | 警报，响铃                       |
| \b       | 退格（删除键）                   |
| \f       | 换页(FF)，将当前位置移到下页开头 |
| \n       | 换行                             |
| \r       | 回车                             |
| \t       | 水平制表符（tab键）              |
| \v       | 垂直制表符                       |



## 命令替换和变量替换



**命令替换$()**

就是将字符串当命令执行，获得命令执行的结果

比如`echo pwd`,输出的是pwd，想要打印路径，就要命令替换`echo $(pwd)`。

也可以使用反引号进行命令替换。

$( )的弊端是，并不是所有的类unix系统都支持这种方式，但反引号是肯定支持的

**如果不进行命令替换，它就会被当成字符串，而命令替换就是将命令替换成命令执行的结果**



**变量替换${}**

${}，可以用来获得变量值，还可以对变量值进行计算变形

**变量替换可以根据变量的状态（是否为空、是否定义等）来改变它的值**



${}对变量值进行截取和替换

```
${file:0:5}            　　　提取最左边的 5 个字节    　　　　　　　　　　　
${file:5:5}            　　　提取第 5 个字节右边的连续 5 个字节    　　　　
${file/dir/path}            将第一个 dir 提换为 path    　　　　　　　　　 
${file//dir/path}    　　　　将全部 dir 提换为 path    　　　　　　　　　
${#file}    　　　　　　　　　 获取变量长度 
```

#\*或##*来去除从头开始的部分

```shell
file=/dir1/dir2/dir3/my.file.txt
${file#*/}						# 去掉从头到第一个/部分
${file##*/}						# 去掉从头到最后一个/部分
```

%或%%来去从尾部切除

```shell
${file%/*}						# 去掉从尾部到最后一个/的部分
${file%/*}						# 去掉从尾部到第一个/的部分
```



根据状态赋值

| 命令                 | 解释                                                  | 备注                 |
| -------------------- | ----------------------------------------------------- | -------------------- |
| ${file-my.file.txt}  | 若 $file 没设定,则使用 my.file.txt 作传回值           | 空值及非空值不作处理 |
| ${file:-my.file.txt} | 若 $file 没有设定或为空值,则使用 my.file.txt 作传回值 | 非空值时不作处理     |
| ${file+my.file.txt}  | 若$file 设为空值或非空值,均使用my.file.txt作传回值    | 没设定时不作处理     |
| ${file:+my.file.txt} | 若 $file 为非空值,则使用 my.file.txt 作传回值         | 没设定及空值不作处理 |
| ${file=txt}          | 若 $file 没设定,则回传 txt ,并将 $file 赋值为 txt     | 空值及非空值不作处理 |
| ${file:=txt}         | 若 $file 没设定或空值,则回传 txt ,将 $file 赋值为txt  | 非空值时不作处理     |
| ${file?my.file.txt}  | 若 $file 没设定,则将 my.file.txt 输出至 STDERR        | 空值及非空值不作处理 |
| ${file:?my.file.txt} | 若 $file没设定或空值,则将my.file.txt输出至STDERR      | 非空值时不作处理     |

​	

### []与[[]]不同之处

主要是整型变量的比较，[]中整型的比较用参数，<>=等用来比较字符串的，而[[]]中的<>=即可以比较整型，又可以比较字符串

[[]]可以直接进行算数运算和比较

[]中的<>表示重定向

**数值运算**

$[]和$(())是一样的，都是进行数学运算的(只能对整型进行计算，浮点数是当作字符串处理的)

$(( )) 

* 引用变量值，可于其前面加 $ 符号来替换，也可以不用
* 大于小于号可以不用转义

$[]

$[]是test命令的另一种表达形式，[ 表达式 ] 注意表达式前后的空格。[表示判断的开始，]表示判断的结束。

[]中只能用==或者!=进行字符串比较，整数比较用-eq等



$[[]]

字符串表达式的加强版。[[ ]]中增加模式匹配特效，增加了许多操作



## if

if可以用来判断文件，字符串，数字等，if判断以if开头，并以fi结尾



**if**

```shell
if [ condition ]; then
	#statements
fi
```

**if-else**

```shell
if [ condition ]; then
	#statements
else
	#statements
fi
```

**if-elif**

```shell
if [ condition ]; then
	#statements
elif [ condition ];
else
	#statements
fi
```



## 运算



### **算数运算**

bash原生中不会进行算数运算，需要借助其他来完成

进行算数运算的三种方式

* $(())
* $[]
* expr

前两中方式可以直接在括号中进行，expr运算需要借助参数



**相加**

```shell
val=`expr 2 + 2`
```

**注意**：使用expr进行运算**数字与运算符之间要有空格**，表达式要完整的被``包括



a=10 b=20

| 运算符 | 说明                                          | 举例                          |
| ------ | --------------------------------------------- | ----------------------------- |
| +      | 加法                                          | `expr $a + $b` 结果为 30。    |
| -      | 减法                                          | `expr $a - $b` 结果为 -10。   |
| *      | 乘法                                          | `expr $a \* $b` 结果为  200。 |
| /      | 除法                                          | `expr $b / $a` 结果为 2。     |
| %      | 取余                                          | `expr $b % $a` 结果为 0。     |
| =      | 赋值                                          | a=$b 将把变量 b 的值赋给 a。  |
| ==     | 相等。用于比较两个数字，相同则返回 true。     | [ $a == $b ] 返回 false。     |
| !=     | 不相等。用于比较两个数字，不相同则返回 true。 | [ $a != $b ] 返回 true。      |

**注意：**条件表达式要放在方括号之间，并且要有空格，例如: **[$a==$b]** 是错误的，必须写成 **[ $a == $b ]**。



### **关系运算**



注意[]的空格

对变量的处理要加双引号

不支持浮点数的判断

如果单独使用<或>，系统会认为是输入输出的重定向

使用-z或者-n检查长度时，没有定义的变量的长度也是0，所以不确定变量有没有定义或初始化时，可以先用-z或-n测试一下

## 

### 布尔运算符

| 运算符 | 说明                                                | 举例                                     |
| :----- | :-------------------------------------------------- | :--------------------------------------- |
| !      | 非运算，表达式为 true 则返回 false，否则返回 true。 | [ ! false ] 返回 true。                  |
| -o     | 或运算，有一个表达式为 true 则返回 true。           | [ $a -lt 20 -o $b -gt 100 ] 返回 true。  |
| -a     | 与运算，两个表达式都为 true 才返回 true。           | [ $a -lt 20 -a $b -gt 100 ] 返回 false。 |



### 逻辑运算符

| 运算符 | 说明       | 举例                                       |
| :----- | :--------- | :----------------------------------------- |
| &&     | 逻辑的 AND | [[ $a -lt 100 && $b -gt 100 ]] 返回 false  |
| \|\|   | 逻辑的 OR  | [[ $a -lt 100 \|\| $b -gt 100 ]] 返回 true |

&&,||还可以用来连接两条命令，组合成的表达式的值由最后一个执行的表达式决定



### 文件测试

| 操作符  | 说明                                                         | 举例                      |
| :------ | :----------------------------------------------------------- | :------------------------ |
| -b file | 检测文件是否是块设备文件，如果是，则返回 true。              | [ -b $file ] 返回 false。 |
| -c file | 检测文件是否是字符设备文件，如果是，则返回 true。            | [ -c $file ] 返回 false。 |
| -d file | 检测文件是否是目录，如果是，则返回 true。                    | [ -d $file ] 返回 false。 |
| -f file | 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 | [ -f $file ] 返回 true。  |
| -g file | 检测文件是否设置了 SGID 位，如果是，则返回 true。            | [ -g $file ] 返回 false。 |
| -k file | 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。  | [ -k $file ] 返回 false。 |
| -p file | 检测文件是否是有名管道，如果是，则返回 true。                | [ -p $file ] 返回 false。 |
| -u file | 检测文件是否设置了 SUID 位，如果是，则返回 true。            | [ -u $file ] 返回 false。 |
| -r file | 检测文件是否可读，如果是，则返回 true。                      | [ -r $file ] 返回 true。  |
| -w file | 检测文件是否可写，如果是，则返回 true。                      | [ -w $file ] 返回 true。  |
| -x file | 检测文件是否可执行，如果是，则返回 true。                    | [ -x $file ] 返回 true。  |
| -s file | 检测文件是否为空（文件大小是否大于0），不为空返回 true。     | [ -s $file ] 返回 true。  |
| -e file | 检测文件（包括目录）是否存在，如果是，则返回 true。          | [ -e $file ] 返回 true。  |

其他检查符：

- **-S**: 判断某文件是否 socket。
- **-L**: 检测文件是否存在并且是一个符号链接。



**printf**

使用 printf 的脚本比使用 echo 移植性好



函数内部局部变量的定义

local 



单引号双引号用来解决变量间有空格的问题

反引号表述命令替换





字符串中有${}，然后另一个字符串也${}



linux用冒号分隔变量，windows用分号分隔变量



